{
  "version": 3,
  "sources": ["../client/view/svg.js", "../client/view/draw-level.js", "../client/maths/evaluate.js", "../client/maths/crosspoint.js", "../client/maths/intercept.js", "../client/maths/slope.js", "../client/maths/line.js", "../client/maths/reflect.js", "../client/view/draw-light.js", "../client/index.js"],
  "sourcesContent": ["export default function svg (tag, classes = [], attrs = {}) {\n  const ns = 'http://www.w3.org/2000/svg'\n  const element = document.createElementNS(ns, tag)\n\n  classes.forEach((cls) => {\n    element.classList.add(cls)\n  })\n\n  for (let [key, value] of Object.entries(attrs)) {\n    element.setAttribute(key, value)\n  }\n\n  return element\n}\n\n", "import svg from './svg'\n\nexport default function drawLevel (root, points) {\n  const d = `M${points[0][0]},${points[0][1]}` + points\n    .slice(1)\n    .map((pair) => `L${pair[0]},${pair[1]}`)\n    .join(' ')\n  const fill = 'none'\n  const stroke = 'black'\n  const path = svg('path', [ 'level' ], { d, fill, stroke, 'stroke-width': 1 })\n  root.appendChild(path)\n}\n\n", "export default function evaluate ({ intercept, slope }) {\n  return function (x) {\n    return slope * x + intercept\n  }\n}\n\n", "import evaluate from './evaluate.js'\n\nexport default function crosspoint (line0, line1) {\n  const slope0 = line0.slope\n  const slope1 = line1.slope\n\n  if (slope0 === slope1) {\n    return crosspointWhenParallels()\n  }\n\n  if (Number.isFinite(slope0) && Number.isFinite(slope1)) {\n    return crosspointWhenBothAreFinite(line0, line1)\n  }\n\n  if (!Number.isFinite(slope0) && slope1 === 0) {\n    return crosspointWhenOneIsInfiniteTheAtherZero(line0, line1)\n  }\n\n  if (!Number.isFinite(slope1) && slope0 === 0) {\n    return crosspointWhenOneIsInfiniteTheAtherZero(line0, line1)\n  }\n\n  return crosspointWhenOneIsInfinite(line0, line1)\n}\n\nfunction crosspointWhenParallels () {\n  // Lines are parallel, i.e. will never intersect\n  return null\n}\n\nfunction crosspointWhenBothAreFinite (line0, line1) {\n  const slope0 = line0.slope\n  const intercept0 = line0.intercept\n\n  const slope1 = line1.slope\n  const intercept1 = line1.intercept\n\n  const factor = 1 / (slope0 - slope1)\n\n  return [\n    factor * (intercept1 - intercept0),\n    factor * (slope0 * intercept1 - intercept0 * slope1),\n  ]\n}\n\nfunction crosspointWhenOneIsInfinite (line0, line1) {\n  const slope0 = line0.slope\n  const intercept0 = line0.intercept\n\n  const slope1 = line1.slope\n  const intercept1 = line1.intercept\n\n  if (!Number.isFinite(slope0)) {\n    const func = evaluate({ slope: slope1, intercept: intercept1 })\n    const y = func(line0.x)\n    const x = (y - intercept1) / slope1\n    return [ x, y ]\n  }\n\n  const func = evaluate({ slope: slope0, intercept: intercept0 })\n  const y = func(line1.x)\n  const x = (y - intercept0) / slope0\n  return [ x, y ]\n}\n\nfunction crosspointWhenOneIsInfiniteTheAtherZero (line0, line1) {\n  const slope0 = line0.slope\n  const intercept0 = line0.intercept\n\n  const slope1 = line1.slope\n  const intercept1 = line1.intercept\n\n  if (!Number.isFinite(slope1)) {\n    if (slope0 === 0) {\n      return [ line1.x, intercept0 ]\n    }\n  }\n\n  if (!Number.isFinite(slope0)) {\n    if (slope1 === 0) {\n      return [ line0.x, intercept1 ]\n    }\n  }\n  return null\n}\n", "export default function computeIntercept (point0, point1) {\n  const [x0, y0] = point0\n  const [x1, y1] = point1\n\n  if (x0 === x1) {\n    if (y1 < y0) {\n      return Number.NEGATIVE_INFINITY\n    }\n    return Number.POSITIVE_INFINITY\n  }\n\n  return (y0 * x1 - y1 * x0) / (x1 - x0)\n}\n\n", "export default function computeSlope (point0, point1) {\n  const [x0, y0] = point0\n  const [x1, y1] = point1\n\n  if (x0 === x1) {\n    if (y1 < y0) {\n      return Number.NEGATIVE_INFINITY\n    }\n    return Number.POSITIVE_INFINITY\n  }\n\n  if (y0 === y1) {\n    return 0\n  }\n\n  return (y1 - y0) / (x1 - x0)\n}\n\n", "import computeIntercept from './intercept.js'\nimport computeSlope from './slope.js'\n\nexport default function computeLineVariables (point0, point1) {\n  const slope = computeSlope(point0, point1)\n  const intercept = computeIntercept(point0, point1)\n\n  if (Number.isFinite(slope)) {\n    return {\n      intercept,\n      slope,\n    }\n  }\n\n  return {\n    intercept,\n    slope,\n    x: point0[ 0 ]\n  }\n}\n\n", "import crosspoint from './crosspoint.js'\nimport evaluate from './evaluate.js'\nimport line from './line.js'\n\nexport default function reflect (line0, line1) {\n  const point = crosspoint(line0, line1)\n\n  if (point === null) {\n    return null\n  }\n\n  /*\n   * Geometric motivation\n   * On a line parallel to the x axis, the reflected line simply switches its\n   * signum and is inverted\n   */\n  if (line1.slope === 0) {\n    if (!Number.isFinite(line0.slope)) {\n      return { intercept: line0.intercept, slope: -line0.slope, x: line0.x }\n    }\n\n    const func = evaluate({ ...line0 })\n    const [ x, y ] = point\n    const slope = -1 / line0.slope\n    const intercept = y - slope * x\n    const y1 = slope * (x + 1) + intercept\n\n    return line([ ...point ], [ x + 1, y1 ])\n  }\n\n  /* Geometric motivation:\n   * If I go one unit in the x direction and look at the difference in y\n   * I have to go the same distance in negative direction along the x axis to\n   * get the delta in y for one unit.\n   * These will give me the second point to form a line with the cross point.\n   */\n  const func = evaluate({ ...line1 })\n  const x = point[ 0 ]\n  const y = func(x)\n  const y1 = func(x + 1)\n\n  return line([ x, y ], [ x - y1, y + 1 ])\n}\n\n", "import crosspoint from '../maths/crosspoint'\nimport line from '../maths/line'\nimport reflect from '../maths/reflect'\nimport svg from './svg'\n\nexport default function drawLight (root, levelPoints, start, direction) {\n  const points = computePoints(start, direction, levelPoints)\n  const d = `M${points[0][0]},${points[0][1]}` + points\n    .slice(1)\n    .map((pair) => `L${pair[0]},${pair[1]}`)\n    .join(' ')\n  const fill = 'none'\n  const stroke = 'orange'\n  const path = svg('path', [ 'light' ], { d, fill, stroke, 'stroke-width': 1 })\n  // c.f. https://jakearchibald.com/2013/animated-line-drawing-svg/#animating-it\n  const length = path.getTotalLength()\n  path.style.strokeDasharray = `${length} ${length}`\n  path.style.strokeDashoffset = length\n  path.getBoundingClientRect()\n  path.style.transition = 'stroke-dashoffset 1s linear'\n  root.appendChild(path)\n  setTimeout(() => path.style.strokeDashoffset = '0', 500)\n}\n\nfunction computePoints (start, direction, levelPoints) {\n  let svgPoints = [ start ]\n  let from = svgCoordToCartesianCoord(start)\n  let to = svgCoordToCartesianCoord(\n    start.map((point, index) => point + direction[ index ])\n  )\n\n  for (let i = 1; i < levelPoints.length - 1; i++) {\n    const current = svgCoordToCartesianCoord(levelPoints[ i ])\n    const next = svgCoordToCartesianCoord(levelPoints[ i + 1 ])\n    const level = line(current, next)\n    const light = line(from, to)\n\n    const point = crosspoint(level, light)\n    if (point) {\n      svgPoints.push(cartesianCoordToSvgCoord(point))\n\n      const reflectedLine = reflect(level, light)\n      const [ x, y ] = point\n      from = [ x, y ]\n      to = [ x + 1,  reflectedLine.slope * (x + 1) + y ]\n      console.log('Crossed', point, reflectedLine, to)\n    }\n  }\n  console.log(svgPoints)\n  return svgPoints\n}\n\nfunction svgCoordToCartesianCoord (point) {\n  // Assume a viewBox of \"0 0 100 100\" here\n  const [ x, y ] = point\n  return [ x, 100 - y ]\n}\n\nfunction cartesianCoordToSvgCoord (point) {\n  // Assume a viewBox of \"0 0 100 100\" here\n  const [ x, y ] = point\n  return [ x, 100 - y ]\n}\n\n", "import drawLevel from './view/draw-level'\nimport drawLight from './view/draw-light'\nimport level from './levels/level0.json'\n\n'use strict';\nconst root = document.getElementById('root')\nconst light = document.getElementById('light')\ndrawLevel(root, level)\ndrawLight(root, level, [ 50, 91 ], [ 0, -1 ])\nupdateFavicon(root)\n\n// TODO: Add a game over screen\n// TODO: Add a share on Twitter screen\n// TODO: Increase attempt on every shoot\n\nfunction updateFavicon (svg) {\n  const icon = document.querySelector('link[rel=\"icon\"]')\n  const serializer = new XMLSerializer()\n  const str = serializer.serializeToString(svg)\n  icon.href = 'data:image/svg+xml;utf8,' + str\n}\n"],
  "mappings": "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",
  "names": []
}
